#!/usr/bin/env ruby
# This intentionally simple to comprehend script acts as the current Ruby On Go CLI.
# Run "rog" in the command line to see available options.

require 'benchmark'
require 'yaml'
require 'fileutils'
require 'pathname'

# Colors
class String
  def red; colorize(self, "\e[1m\e[31m"); end
  def green; colorize(self, "\e[1m\e[32m"); end
  def dark_green; colorize(self, "\e[32m"); end
  def yellow; colorize(self, "\e[1m\e[33m"); end
  def blue; colorize(self, "\e[1m\e[34m"); end
  def dark_blue; colorize(self, "\e[34m"); end
  def pur; colorize(self, "\e[1m\e[35m"); end
  def colorize(text, color_code) "#{color_code}#{text}\e[0m" end
  def say(with_color = :blue); puts "#{self.send(with_color.to_sym)}"; end
end

# gem source path
@gem_path = File.join(File.dirname(__FILE__))

# just read two arguments (we will do full option parsing later)
$:.unshift @gem_path
@command  = ARGV[0]
@name     = ARGV[1] if ARGV.length > 0

# read deploy username and domain
@rog_usr = nil
@rog_host = nil
if ARGV.length > 1
  @rog_usr = ARGV[2]
  @rog_host   = ARGV[3] if ARGV.length > 2

  # Conventionally, defaults come from the Name argument:
  # Name=rubyongo.org => DomainUsername: rubyongo, DomainHost: rubyongo.org
  # Name=rubyongo => DomainUsername: rubyongo, DomainHost: rubyongo.shop
  @rog_usr ||= @name.split('.').first
  @rog_host ||= @name =~ /\./ ? @name : "#{@name}.shop"
end

# code generation path, where to put generate files
# just take the current folder for now
@gen_path = Dir.pwd

# load rubyongo
$LOAD_PATH.unshift File.expand_path("../../lib", __FILE__)
require "rubyongo/version"

version = ::Rubyongo.version

USAGE = <<-EOF
#
# Welcome to #{'RubyOnGo'.dark_blue} v#{version}
#
# This software is intended to help you with everyday webshop building.
#
# Use it as you #{'dodo'.green}.
#

Usage:

  rog new Name.ext [DeployUsername DeployDomainHost] # generates a new webshop in the current folder, pass usr and host for custom deployment credentials (default: usr: Name, host: Name.ext)
  rog init                                           # automated deployment pipeline installation
  rog start                                          # starts the Panel backend (rackup)
  rog deploy                                         # deploys code and publishes

EOF

def print_backtrace(exception)
  exception.backtrace.join("\n\t").to_s.blue
end

def print_usage
  puts USAGE
end

def set_env
  if @name == '--production'
    ENV['RACK_ENV'] = :production.to_s
  else
    ENV['RACK_ENV'] = :development.to_s
  end
end

def settings
  @settings ||= YAML.load_file('panel.yml')
end

# Generate a file by copying
def gen(to, *from)
  src = File.join(@gem_path, '..', *from)
  FileUtils.cp_r(src, to)
end

# Run some shell command, print success message in green, on fail print error in red
def run_cmd(command, success_message)
  r = `#{command}`
  if r =~ //
    "#{success_message}".say(:green)
  else
    r.say(:red)
  end
end

# Generate a file by copying and modifying some data along the way
def genmod(replacements, to, *from)
  src = File.join(@gem_path, '..', *from)
  content = File.read(src)
  replacements.each {|k, v| content.gsub!(/#{k}/, "#{v}")}

  # when copying a file to a directory, use the src's basename, else just copy to file
  dest_pathname = Pathname.new(to)
  destination   = dest_pathname.directory? ? File.join(to, File.basename(src)) : to

  File.open(destination, 'w') {|f| f.write content }
end

# Create rog folder with `hugo new site`
def new_rog_dir(name, path)
  if Dir.exists?(path)
    "#{name} exists at #{path}.".say(:red)
    exit(1)
  else
    run_cmd("hugo new site #{name}", "Created #{path}.")
  end
end

def generate_rog_dir(name, to_path, replacements={})
  if Dir.exists?(to_path)
    # Generate static generator paths
    gen(to_path, 'themes')

    # Generate Panel paths and populate with files
    gen(to_path, 'panel')
    gen(to_path, 'panel', 'views')
    gen(to_path, 'gen', 'Rakefile')
    gen(to_path, 'gen', 'test')
    gen(to_path, 'gen', 'config.ru')
    gen(to_path, 'gen', '.gitignore')
    gen(to_path, 'sys')
    gen(to_path, 'static')

    # Generate the Gemfile
    genmod(replacements, to_path, 'gen', 'Gemfile')

    #Generate Hugo config file
    genmod(replacements, to_path, 'gen', 'config.toml')

    # Generate Panel settings file
    genmod(replacements, to_path, 'gen', 'panel.yml')

    # Generate sys/host_vars settings
    to_file = File.join(to_path, 'sys', 'host_vars', "#{replacements['rog-host']}.yml")
    genmod(replacements, to_file, 'gen', 'sys', 'host_vars', 'example.com.yml')

    # Generate host lists for sys
    {"env.yml"     => File.join(to_path, 'sys', "env.yml"),
     "restart.yml" => File.join(to_path, 'sys', "restart.yml"),
      "rogs" => File.join(to_path, 'sys', "rogs")}.each do |filename, to_file|
      genmod(replacements, to_file, 'gen', 'sys', filename)
    end
  else
    "#{name} does not exist".say(:red)
    exit(1)
  end
end

def populate_local_git_repo(path)
  run_cmd "cd #{path}; git init; git add .; git commit -am 'Add generated rog'", "Development and/or content git repository #{path}/.git."
end

def first_publish(path)
  run_cmd "cd #{path}; hugo", "Published #{path}."
end

def ensure_gem(name, path)
  r = `gem list -ie #{name}`
  if r =~ /true/
    "#{name} is present.".say(:green)
  else
    "Missing #{name}, installing...".say(:red)
    `cd #{path}; gem install #{name}`
  end
end

def ensure_bundler_and_bundle(path)
  ensure_gem('bundler', path)
  run_cmd "cd #{path}; bundle", "Bundled gems."
end

# Create a new rog site
def new_rog(name, settings={})
  if name == nil || name == ""
    "Please supply a name for the webshop.".say(:red)
    return
  end
  path = File.join(@gen_path, name)
  new_rog_dir(name, path) # run hugo new site
  generate_rog_dir(name, path, settings) # populate the generated site with rog
  first_publish(path) # publish the site to static generate the public folder for the first time (prevent an empty site)
  ensure_bundler_and_bundle(path) # check if bundler is installed, if not install it now, then bundle
  populate_local_git_repo(path) # set up an initial repo
  "Success".say(:green)
end

# Run the Panel's backend
def run_rog
  set_env
  require 'rubyongo'
  "Rubyongo #{ENV['RACK_ENV']}".say(:dark_blue)
  Rubyongo::Kit.run!
end

# Deploy this rog site
def deploy_rog
  usr = settings['production']['usr']
  host = settings['production']['host']
  exec("cd sys; ./rogd #{usr} #{host}")
end

# Run deployment install.
def init_rog
  usr = settings['production']['usr']
  host = settings['production']['host']
  provider = "#{usr}@#{host}"
  # cd sys; roginit rubyongo rubyongo.org rubyongo@rubyongo.org:~/rubyongo.org.git rubyongo@rubyongo.org
  exec("cd sys; ./roginit #{usr} #{host} #{provider}:~/#{host}.git #{provider}; ./rogup #{usr} #{host}")
end

# Upgrade the setup.
def upgrade_rog
  usr = settings['production']['usr']
  host = settings['production']['host']
  exec("cd sys; ./rogup #{usr} #{host}")
end

def run_hugo_server
  set_env
  args = "" # TODO: allow passing arguments, which? let's add proper arguments parsing much later, when we know exactly what the CLI interface should do and achieve tasks.
  exec("hugo server #{args}")
end

def dodo
  #time = Benchmark.realtime do
    if @command == 'help' || @command == nil || @command == ""
      print_usage
    elsif @command == 'new'
      new_rog(@name, { 'rog-usr' => @rog_usr, 'rog-host' => @rog_host })
    elsif @command == 's' || @command == 'start'
      run_rog
    elsif @command == 'd' || @command == 'deploy'
      deploy_rog
    elsif @command == 'i' || @command == 'init'
      init_rog
    elsif @command == 'up' || @command == 'upgrade'
      upgrade_rog
    elsif @command == 'h' || @command == 'hugo'
      run_hugo_server
    end
  #end
  #"Realtime: #{time}sec\n".say(:yellow)
end

# run
begin
  dodo
rescue StandardError => e
  "Runtime exception: #{e.message.to_s.blue}\nBacktrace:\n#{print_backtrace(e)}".say(:red)
  print_usage
end
